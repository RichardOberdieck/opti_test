{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Testing optimization code","text":""},{"location":"#tldr","title":"TL,DR;","text":"<ul> <li>I differentiate between unit and performance tests: unit tests assess correctness, performance tests assess speed</li> </ul>"},{"location":"#unit-testing","title":"Unit testing","text":"<ul> <li>Most of optimization code is like regular code, and it can be unit tested the same way.</li> <li>Unit testing a model is often difficult, as it is difficult to break it down into smaller parts (units). Property-based testing using very small instances often is a good tool here. Python has the <code>hypothesis</code> framework for this.</li> <li>One can spend time on unit testing individual equations, however I have found this to not add a lot of value.</li> <li>Modeling frameworks can be a way to get around license limitations for a commercial solver when testing (looking at you, Gurobi). However, I recommend that you run the full test suite with the real (i.e. production) configuration at least once before releasing.</li> </ul>"},{"location":"#performance-testing","title":"Performance testing","text":"<ul> <li>For performance testing, we need three things: real instances, real hardware, real setup. If one of these is missing, the test does not mean much.</li> <li>If performance matters, then performance testing is as important as unit testing.</li> <li>The same patterns as in unit testing apply: arrange, act, assert. For performance tests, it can be useful to also record performance metrics over time, such as time, objective function value etc. A simple database can be a valuable friend.</li> <li>Performance testing gets easier when an API or CLI is available. Writing them is easy, and they save a lot of time.</li> </ul>"},{"location":"#learn-more","title":"Learn more","text":"<p>Was the TL,DR; not enough? Then let's dive in :) - Introduction: Why is testing powerful? Can it really work for optimization applications? - Principles of testing: What is a unit, integration and performance test? What makes a test good? What is a property-based test? - Examples for unit testing: How to think about unit tests for optimization code, based on a few example from the code in the repository. - Examples for performance testing: A small performance testing setup for the code in the repository.</p>"},{"location":"#liked-what-you-read","title":"Liked what you read?","text":"<p>Contribute! Leave a star on Github! Give me a shout on bsky or LinkedIn! Check out my website.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Testing means making sure stuff works. So why don't we do it? Actually, we do! Almost always, we write one or two examples, run them in a Jupyter notebook, \"just to make sure it works\". That's testing!</p> <p>So why is it worth talking about? Because often, we only test a small part of all the components of our code. Because often, we do this manually when we done with something. This is as if the only testing Mercedes would do for your new car would be to have someone drive it around the factory once and declare it ok. Ask yourself: if this was the only testing done, would you still drive the car?</p> <p>My guess is no. For me, it's a hard no (also, I don't have a Mercedes). I want every nut and bolt of my imaginary Mercedes to be stress tested way beyond anything I will ever encounter in real life.</p> <p>The same is true for software. It may not put your life at risk if it malfunctions (although that is not unheard of), but just consider every piece of software you interact with on a daily basis. Your expectation is that it runs correctly. But how can you be sure? Because we test.</p>"},{"location":"introduction/#testing-software-is-easy","title":"Testing software is easy","text":"<p>Staying with car analogy for a minute. Consider what you need to do to test a physical object: you need controlled conditions, you need infrastructure, you need space. Software testing needs the same things, but they are all digital: we need computers, we need isolated software environments and so on, but they only exist as digits, not in \"real life\".</p> <p>So testing software is infinitely easier than testing hardware. The only reason we don't do it properly is because don't prioritize it, or we don't know how to.</p> <p>I hope I convinced you of the fact that you should prioritize it, let's now tackle the \"how-to\".</p> <p>Go to Principles of testing</p>"},{"location":"performance-tests/","title":"Examples for performance testing","text":""},{"location":"principles/","title":"Principles of testing","text":""},{"location":"principles/#the-basics","title":"The basics","text":"<p>A test should always test \"one thing\". In other words, in an ideal world, there is a single question a test answers. Does this function return 4 when I provide 2 as an argument? Is the problem solved to optimality with an objective function value of 19.993? A new question, a new test.</p> <p>The pattern to arrive at such structure is the arrange, act, assert structure. Let me show a small example:</p> <pre><code>def multiply(x, y):\n    return x*y\n\n\ndef test_multiply():\n    # Arrange\n    x = 2\n    y = 5\n\n    # Act\n    result = multiply(x, y)\n\n    # Assert\n    assert 10 == result\n</code></pre> <p>The comments are critical by the way. Believe it or not, I actually add them to every test I write, always. Ask my colleagues. They think it is slightly crazy. That's ok. To me, if I cannot segment my test into these three buckets, something is off. It shows what I am focussing on. It makes it very easy to understand.</p>"},{"location":"principles/#what-type-of-testing-is-there","title":"What type of testing is there?","text":"<p>There is no natural law for testing, just some people having opinions. Here are mine: - A unit test is a test which covers a single function or method in a code base. Very rarely it may cover two, but that is the exception. As a rule of thumb, every function or method should be tested. - An integration test is a test which covers a certain \"part\" of the code, or an expected flow of data through the application. It is by definition more high-level than a unit test, and combines different components to check whether that part of the application is behaving as expected. Sometimes, we also call something an integration test if it uses actual database access or takes a long time to run. - An end-to-end test runs the entire application end to end (as the name suggests). It is the most high-level type of test. - A performance test focusses on the performance of the application, typically something like throughput or accuracy.</p> <p>The lines between all of these are blurry.</p>"},{"location":"principles/#property-based-testing","title":"Property-based testing","text":"<p>Just watch this.</p> <p>Ok, if you are still reading: property-based testing means that instead of testing a specific case, we test a specific property. An example:</p> <p>When I run my function <code>multiply_by_2(x)</code>, is the result divisible by 2?</p> <p>This works well for optimization models:</p> <p>Does the solution always connect all turbines? Do I get <code>None</code> if the problem is infeasible? Do I ever exceed the max number of cable types?</p> <p>In other words: does the solution follow what the equations should encode?</p> <p>So if it is so awesome, why don't we use property-based testing all the time? Two reasons: 1. The setup is laborious. ChatGPT can help here, but it still is not something I want to do for everything. 2. Because it tries to find a falsifying example, it runs through a lot of different combinations, which takes time. So if you have thousands of tests, this will become an issue.</p> <p>Got it? Let's look at some examples for unit testing!</p>"},{"location":"slides/","title":"Welcome","text":""},{"location":"slides/#structure","title":"Structure","text":"<ol> <li>Why is this a topic?</li> <li>What is hard about testing optimization code?</li> <li>Unit testing optimization code</li> <li>Performance testing optimization code</li> <li>Cake</li> </ol>"},{"location":"slides/#why-is-this-a-topic","title":"Why is this a topic?","text":"<p>Testing helps find problems before they become actual problems</p> <p></p> <p><sub>https://motoroctane.com/wp-content/uploads/2020/11/car-testing.jpg?x46283</sub></p>"},{"location":"slides/#what-is-hard-about-testing-optimization-code","title":"What is hard about testing optimization code?","text":"<ol> <li>Most people who write optimization code have little experience writing unit tests</li> <li>It often makes little logical sense to test sub-components of a mathematical model.</li> </ol>"},{"location":"slides/#the-test-case-today-insert-pun-related-laughter","title":"The test case today (insert pun-related laughter)","text":"<ul> <li>How to connect wind turbines (\"WTGs\") to offshore substations (\"OSS\")</li> </ul> <p><sub>https://pub.mdpi-res.com/energies/energies-14-03615/article_deploy/html/images/energies-14-03615-g003.png?1624412096</sub></p>"},{"location":"slides/#describing-the-model","title":"Describing the model","text":"<ul> <li>Minimize cost of cables</li> <li>Subject to<ul> <li>All turbines need to be connected</li> <li>Flow balance (flow in + turbine power = flow out)</li> <li>Respect flow limits on cable type</li> <li>Cables cannot cross</li> <li>Max number of different cable types</li> </ul> </li> </ul> <p>The detailed mathematical model can be found in the docs, or read Martina Fischetti's thesis.</p>"},{"location":"slides/#lets-have-a-look","title":"Let's have a look!","text":""},{"location":"slides/#unit-testing-optimization-code","title":"Unit testing optimization code","text":"<ul> <li>Unit = small component with expected behavior</li> <li>Property-based testing good approach for optimization models.</li> <li>Unit testing individual equations is too much</li> <li>Modeling frameworks can be a way to get around license limitations for a commercial solver when testing (looking at you, Gurobi).</li> <li>However, I recommend that you run the full test suite with the real (i.e. production) configuration at least once before releasing.</li> </ul>"},{"location":"slides/#property-based-testing","title":"Property-based testing","text":"<p>Instead of testing a specific case, we test a specific property. An example:</p> <p>When I run my function <code>multiply_by_2(x)</code>, is the result divisible by 2?</p> <p>This works well for optimization models:</p> <p>Does the solution always connect all turbines? Do I get <code>None</code> if the problem is infeasible? Do I ever exceed the max number of cable types?</p> <p>In other words: does the solution follow what the equations should encode?</p> <p>Caveat: This only works with small instances in a somewhat reasonable time</p>"},{"location":"slides/#performance-testing-optimization-code","title":"Performance testing optimization code","text":"<ul> <li>real instances, real hardware, real setup</li> <li>Performance testing is as important as unit testing</li> <li>The same patterns as in unit testing apply: arrange, act, assert.</li> <li>Record performance metrics over time</li> <li>Create an API or CLI, they save a lot of time.</li> </ul>"},{"location":"slides/#cake","title":"Cake","text":""},{"location":"unit-tests/","title":"Examples for unit testing","text":""}]}